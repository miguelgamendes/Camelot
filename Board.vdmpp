/*

              .
             /.\
             |.|
             |.|
             |.|
             |.|   ,'`.
             |.|  ;\  /:
             |.| /  \/  \
             |.|<.<_\/_>,>
             |.| \`.::,'/
             |.|,'.'||'/.
          ,-'|.|.`.____,'`.
        ,' .`|.| `.____,;/ \
       ,'=-.`|.|\ .   \ |,':
      /_   :)|.|.`.___:,:,'|.
     (  `-:;\|.|.`.)  |.`-':,\
     /.   /  ;.:--'   |    | ,`.
    / _>-'._.'-'.     |.   |' / )._
   :.'    ((.__;/     |    |._ /__ `.___
   `.>._.-' |)=(      |.   ;  '--.._,`-.`.
            ',--'`-._ | _,:          `='`'
            /_`-. `..`:'/_.\
           :__``--..\\_/_..:
           |  ``--..,:;\__.|
           |`--..__/:;  :__|
           `._____:-;_,':__;
            |:'    /::'  `|
            |,---.:  :,-'`;
            : __  )  ;__,'\
            \' ,`/   \__  :
            :. |,:   :  `./
            | `| |   |   |:
            |  | |   |   ||
            |  | |   |   ||
            |  | |   '   ||
            |  : |    \  ||
            |  ; :    :  ||
            | / ,;    |\,'`.
            ;-.(,'    '-._,-`.
          ,'-.//          `--'
          `---'
*/

class Board
/*
	Data structure that contains the entire game board
	
	k - white knight
	p - white pawn
	
	K - black knight
	P - black pawn
*/
	instance variables
		private board : seq of seq of char := [];
		private pieces : seq of Piece := [];
		
	values
		X = 11;
		Y = 15;
		
	operations
		public Board : () ==> Board
		Board() == (
			init();
		);
		
		public init : () ==> ()
		init() == (
			dcl auxLine : seq of char := [];
			
			board := [];
			
			for counter = 0 to Y do (
				for counter2 = 0 to X do (
					-- corner cases
					if counter + counter2 <= 2 then
						auxLine := auxLine ^ ['#'];
					if counter2 - counter >= 9 then
						auxLine := auxLine ^ ['#'];
					if counter - counter2 >= 13 then
						auxLine := auxLine ^ ['#'];
					if counter + counter2 >= 24 then
						auxLine := auxLine ^ ['#'];
						
					-- additional cases
					if counter = 0 and (counter2 = 3 or counter2 = 4 or counter2 = 7 or counter2 = 8) then
						auxLine := auxLine ^ ['#'];
					if counter = Y and (counter2 = 3 or counter2 = 4 or counter2 = 7 or counter2 = 8) then
						auxLine := auxLine ^ ['#'];
					
					if len auxLine = counter2 then
						auxLine := auxLine ^ [' '];
				);
				board := board ^ [auxLine];
				auxLine := []; -- reset auxLine for next iteration
			);
		);
		
		public begin : () ==> ()
		begin() == (
			init();
			
			-- piece placement
			
			-- black pieces
			
			addPiece(2,5,"knight", "black");
			addPiece(3,5,"piece", "black");
			addPiece(4,5,"piece", "black");
			addPiece(5,5,"piece", "black");
			addPiece(6,5,"piece", "black");
			addPiece(7,5,"piece", "black");
			addPiece(8,5,"piece", "black");
			addPiece(9,5,"knight", "black");
			
			addPiece(3,6,"knight", "black");
			addPiece(4,6,"piece", "black");
			addPiece(5,6,"piece", "black");
			addPiece(6,6,"piece", "black");
			addPiece(7,6,"piece", "black");
			addPiece(8,6,"knight", "black");
			
			-- white pieces
			
			addPiece(3,9,"knight","white");
			addPiece(4,9,"piece","white");
			addPiece(5,9,"piece","white");
			addPiece(6,9,"piece","white");
			addPiece(7,9,"piece","white");
			addPiece(8,9,"knight","white");
			
			addPiece(2,10,"knight","white");
			addPiece(3,10,"piece","white");
			addPiece(4,10,"piece","white");
			addPiece(5,10,"piece","white");
			addPiece(6,10,"piece","white");
			addPiece(7,10,"piece","white");
			addPiece(8,10,"piece","white");
			addPiece(9,10,"knight","white");
			
			updatePieces();
		);
		
		public print : () ==> ()
		print() == (
			dcl auxBoard : seq of seq of char := board;
			dcl auxLine : seq of char := [];
			
			IO`print("\n"); -- this is necessary for proper console output
			for counter = 0 to Y do (
				auxLine := hd auxBoard;
				auxBoard := tl auxBoard;
				IO`print(auxLine);
				IO`print("\n");
			)
		);
		
		public changeElement : int * int * char ==> ()
		changeElement(x, y, newElem) == (
			dcl auxBoard : seq of seq of char := [];
			dcl auxPreBoard : seq of seq of char := [];
			dcl auxPostBoard : seq of seq of char := board;
			dcl auxLine : seq of char := [];
			dcl auxPreLine : seq of char := [];
			dcl auxPostLine : seq of char := [];
			
			-- find Y
			for counter = 0 to y do (
				if counter <> 0 then
					auxPreBoard := auxPreBoard ^ [hd auxBoard];
				auxBoard := [hd auxPostBoard];
				auxPostBoard := tl auxPostBoard;
			);
			
			-- find X
			auxPostLine := hd auxBoard;
			for counter = 0 to x do (
				if counter <> 0 then
					auxPreLine := auxPreLine ^ [hd auxLine];
				auxLine := [hd auxPostLine];
				auxPostLine := tl auxPostLine;
			);
			
			-- rebuild line, with new element
			auxLine := auxPreLine ^ [newElem];
			auxLine := auxLine ^ auxPostLine;
			
			--rebuild board, with new line
			auxBoard := auxPreBoard ^ [auxLine];
			auxBoard := auxBoard ^ auxPostBoard;
			
			board := auxBoard;
		);
		
		public getElement : int * int ==> char
		getElement(x, y) == (
			dcl finalElem : char;
			dcl auxLine : seq of char := [];
			dcl auxBoard : seq of seq of char := board;
		
			for counter = 0 to y do (
				auxLine := hd auxBoard;
				auxBoard := tl auxBoard;
			);
			
			for counter = 0 to x do (
				finalElem := hd auxLine;
				auxLine := tl auxLine;
			);
			
			return finalElem;
		);
		
		public addPiece : int * int * seq of char * seq of char ==> ()
		addPiece(x, y, type, color) == (
			dcl newPiece : Piece := new Piece(x, y, type, color);
			pieces := pieces ^ [newPiece];
		);
		
		public getPieceValue : int * int ==> char
		getPieceValue(x, y) == (
			for piece in pieces do (
				if piece.getX() = x and piece.getY() = y then
					return piece.getPiece();
			);
			
			return ' ';
		);
		
		public movePiece : int * int * int * int ==> ()
		movePiece(x1, y1, x2, y2) == (
			for piece in pieces do (
				if piece.getX() = x1 and piece.getY() = y1 then
					piece.move(x2, y2);
			);
		);
		
		public updatePieces : () ==> ()
		updatePieces() == (
			for piece in pieces do (
				changeElement(piece.getX(), piece.getY(), piece.getPiece());
			);
		);
		
		public distance : int * int * int * int ==> int
		distance(x1, y1, x2, y2) == (
			-- horizontal distance
			if abs(x2 - x1) = 1 and abs(y2 - y1) = 0 then
				return 1;
				
			-- vertical distance
			if abs(x2 - x1) = 0 and abs(y2 - y1) = 1 then
				return 1;
				
			-- diagonal distance
			if abs(x2 - x1) = 1 and abs(y2 - y1) = 1 then
				return 1;
			if abs(x2 - x1) = 2 then (
				if abs(y2 - y1) = 0 then
					return 2;
				if abs(y2 - y1) = 2 then
					return 2;
			);
			if abs(y2 - y1) = 2 then (
				if abs(x2 - x1) = 0 then
					return 2;
			);
			
			-- last case scenario, return invalid
			return -1;
		);
		
		public move : seq of char * int * int * int * int ==> bool
		move(color, x1, y1, x2, y2) == (
			dcl moveDist : int := distance(x1, y1, x2, y2);
			
			-- check for valid distances
			if moveDist = -1 then
				return false;
				
			-- check for valid piece
			if color = "white" and (getPieceValue(x1, y1) = 'K' or getPieceValue(x1, y1) = 'P') then
				return false;
			if color = "black" and (getPieceValue(x1, y1) = 'k' or getPieceValue(x1, y1) = 'p') then
				return false;
				
			-- check for empty destination
			if getPieceValue(x2, y2) <> ' ' then (
				IO`println("Invalid destination =[");
				return false;
			);
				
			-- here we can proceed with the move
			movePiece(x1, y1, x2, y2);
			
			-- reset board, and update display according to new piece positions
			init();
			updatePieces();
			
			return true;
		);

end Board